// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: sidechain_types.proto
// Protobuf C++ Version: 5.26.0-rc1

#ifndef GOOGLE_PROTOBUF_INCLUDED_sidechain_5ftypes_2eproto_2epb_2eh
#define GOOGLE_PROTOBUF_INCLUDED_sidechain_5ftypes_2eproto_2epb_2eh

#include <limits>
#include <string>
#include <type_traits>
#include <utility>

#include "google/protobuf/port_def.inc"
#if PROTOBUF_VERSION != 5026000
#error "Protobuf C++ gencode is built with an incompatible version of"
#error "Protobuf C++ headers/runtime. See"
#error "https://protobuf.dev/support/cross-version-runtime-guarantee/#cpp"
#endif
#include "google/protobuf/port_undef.inc"
#include "google/protobuf/io/coded_stream.h"
#include "google/protobuf/arena.h"
#include "google/protobuf/arenastring.h"
#include "google/protobuf/generated_message_bases.h"
#include "google/protobuf/generated_message_tctable_decl.h"
#include "google/protobuf/generated_message_util.h"
#include "google/protobuf/metadata_lite.h"
#include "google/protobuf/generated_message_reflection.h"
#include "google/protobuf/message.h"
#include "google/protobuf/repeated_field.h"  // IWYU pragma: export
#include "google/protobuf/extension_set.h"  // IWYU pragma: export
#include "google/protobuf/unknown_field_set.h"
#include "types.pb.h"
// @@protoc_insertion_point(includes)

// Must be included last.
#include "google/protobuf/port_def.inc"

#define PROTOBUF_INTERNAL_EXPORT_sidechain_5ftypes_2eproto

namespace google {
namespace protobuf {
namespace internal {
class AnyMetadata;
}  // namespace internal
}  // namespace protobuf
}  // namespace google

// Internal implementation detail -- do not use these members.
struct TableStruct_sidechain_5ftypes_2eproto {
  static const ::uint32_t offsets[];
};
extern const ::google::protobuf::internal::DescriptorTable
    descriptor_table_sidechain_5ftypes_2eproto;
namespace tari {
namespace rpc {
class BuildInfo;
struct BuildInfoDefaultTypeInternal;
extern BuildInfoDefaultTypeInternal _BuildInfo_default_instance_;
class ConfidentialOutputData;
struct ConfidentialOutputDataDefaultTypeInternal;
extern ConfidentialOutputDataDefaultTypeInternal _ConfidentialOutputData_default_instance_;
class FlowInfo;
struct FlowInfoDefaultTypeInternal;
extern FlowInfoDefaultTypeInternal _FlowInfo_default_instance_;
class ManifestInfo;
struct ManifestInfoDefaultTypeInternal;
extern ManifestInfoDefaultTypeInternal _ManifestInfo_default_instance_;
class SideChainFeature;
struct SideChainFeatureDefaultTypeInternal;
extern SideChainFeatureDefaultTypeInternal _SideChainFeature_default_instance_;
class TemplateRegistration;
struct TemplateRegistrationDefaultTypeInternal;
extern TemplateRegistrationDefaultTypeInternal _TemplateRegistration_default_instance_;
class TemplateType;
struct TemplateTypeDefaultTypeInternal;
extern TemplateTypeDefaultTypeInternal _TemplateType_default_instance_;
class ValidatorNodeRegistration;
struct ValidatorNodeRegistrationDefaultTypeInternal;
extern ValidatorNodeRegistrationDefaultTypeInternal _ValidatorNodeRegistration_default_instance_;
class WasmInfo;
struct WasmInfoDefaultTypeInternal;
extern WasmInfoDefaultTypeInternal _WasmInfo_default_instance_;
}  // namespace rpc
}  // namespace tari
namespace google {
namespace protobuf {
}  // namespace protobuf
}  // namespace google

namespace tari {
namespace rpc {

// ===================================================================


// -------------------------------------------------------------------

class WasmInfo final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:tari.rpc.WasmInfo) */ {
 public:
  inline WasmInfo() : WasmInfo(nullptr) {}
  ~WasmInfo() override;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR WasmInfo(
      ::google::protobuf::internal::ConstantInitialized);

  inline WasmInfo(const WasmInfo& from) : WasmInfo(nullptr, from) {}
  inline WasmInfo(WasmInfo&& from) noexcept
      : WasmInfo(nullptr, std::move(from)) {}
  inline WasmInfo& operator=(const WasmInfo& from) {
    CopyFrom(from);
    return *this;
  }
  inline WasmInfo& operator=(WasmInfo&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const WasmInfo& default_instance() {
    return *internal_default_instance();
  }
  static inline const WasmInfo* internal_default_instance() {
    return reinterpret_cast<const WasmInfo*>(
        &_WasmInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 5;
  friend void swap(WasmInfo& a, WasmInfo& b) { a.Swap(&b); }
  inline void Swap(WasmInfo* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(WasmInfo* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  WasmInfo* New(::google::protobuf::Arena* arena = nullptr) const final {
    return ::google::protobuf::Message::DefaultConstruct<WasmInfo>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const WasmInfo& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const WasmInfo& from) { WasmInfo::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(WasmInfo* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "tari.rpc.WasmInfo"; }

 protected:
  explicit WasmInfo(::google::protobuf::Arena* arena);
  WasmInfo(::google::protobuf::Arena* arena, const WasmInfo& from);
  WasmInfo(::google::protobuf::Arena* arena, WasmInfo&& from) noexcept
      : WasmInfo(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::MessageLite::ClassData* GetClassData()
      const final;

 public:
  ::google::protobuf::Metadata GetMetadata() const final;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kAbiVersionFieldNumber = 1,
  };
  // uint32 abi_version = 1;
  void clear_abi_version() ;
  ::uint32_t abi_version() const;
  void set_abi_version(::uint32_t value);

  private:
  ::uint32_t _internal_abi_version() const;
  void _internal_set_abi_version(::uint32_t value);

  public:
  // @@protoc_insertion_point(class_scope:tari.rpc.WasmInfo)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 1, 0,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from);
    ::uint32_t abi_version_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_sidechain_5ftypes_2eproto;
};
// -------------------------------------------------------------------

class ManifestInfo final : public ::google::protobuf::internal::ZeroFieldsBase
/* @@protoc_insertion_point(class_definition:tari.rpc.ManifestInfo) */ {
 public:
  inline ManifestInfo() : ManifestInfo(nullptr) {}
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR ManifestInfo(
      ::google::protobuf::internal::ConstantInitialized);

  inline ManifestInfo(const ManifestInfo& from) : ManifestInfo(nullptr, from) {}
  inline ManifestInfo(ManifestInfo&& from) noexcept
      : ManifestInfo(nullptr, std::move(from)) {}
  inline ManifestInfo& operator=(const ManifestInfo& from) {
    CopyFrom(from);
    return *this;
  }
  inline ManifestInfo& operator=(ManifestInfo&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ManifestInfo& default_instance() {
    return *internal_default_instance();
  }
  static inline const ManifestInfo* internal_default_instance() {
    return reinterpret_cast<const ManifestInfo*>(
        &_ManifestInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 7;
  friend void swap(ManifestInfo& a, ManifestInfo& b) { a.Swap(&b); }
  inline void Swap(ManifestInfo* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ManifestInfo* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ManifestInfo* New(::google::protobuf::Arena* arena = nullptr) const final {
    return ::google::protobuf::internal::ZeroFieldsBase::DefaultConstruct<ManifestInfo>(arena);
  }
  using ::google::protobuf::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const ManifestInfo& from) {
    ::google::protobuf::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::google::protobuf::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const ManifestInfo& from) {
    ::google::protobuf::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }

  public:
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "tari.rpc.ManifestInfo"; }

 protected:
  explicit ManifestInfo(::google::protobuf::Arena* arena);
  ManifestInfo(::google::protobuf::Arena* arena, const ManifestInfo& from);
  ManifestInfo(::google::protobuf::Arena* arena, ManifestInfo&& from) noexcept
      : ManifestInfo(arena) {
    *this = ::std::move(from);
  }

 public:
  ::google::protobuf::Metadata GetMetadata() const final;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  // @@protoc_insertion_point(class_scope:tari.rpc.ManifestInfo)
 private:
  class _Internal;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from);
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  friend struct ::TableStruct_sidechain_5ftypes_2eproto;
};
// -------------------------------------------------------------------

class FlowInfo final : public ::google::protobuf::internal::ZeroFieldsBase
/* @@protoc_insertion_point(class_definition:tari.rpc.FlowInfo) */ {
 public:
  inline FlowInfo() : FlowInfo(nullptr) {}
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR FlowInfo(
      ::google::protobuf::internal::ConstantInitialized);

  inline FlowInfo(const FlowInfo& from) : FlowInfo(nullptr, from) {}
  inline FlowInfo(FlowInfo&& from) noexcept
      : FlowInfo(nullptr, std::move(from)) {}
  inline FlowInfo& operator=(const FlowInfo& from) {
    CopyFrom(from);
    return *this;
  }
  inline FlowInfo& operator=(FlowInfo&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const FlowInfo& default_instance() {
    return *internal_default_instance();
  }
  static inline const FlowInfo* internal_default_instance() {
    return reinterpret_cast<const FlowInfo*>(
        &_FlowInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 6;
  friend void swap(FlowInfo& a, FlowInfo& b) { a.Swap(&b); }
  inline void Swap(FlowInfo* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(FlowInfo* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  FlowInfo* New(::google::protobuf::Arena* arena = nullptr) const final {
    return ::google::protobuf::internal::ZeroFieldsBase::DefaultConstruct<FlowInfo>(arena);
  }
  using ::google::protobuf::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const FlowInfo& from) {
    ::google::protobuf::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::google::protobuf::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const FlowInfo& from) {
    ::google::protobuf::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }

  public:
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "tari.rpc.FlowInfo"; }

 protected:
  explicit FlowInfo(::google::protobuf::Arena* arena);
  FlowInfo(::google::protobuf::Arena* arena, const FlowInfo& from);
  FlowInfo(::google::protobuf::Arena* arena, FlowInfo&& from) noexcept
      : FlowInfo(arena) {
    *this = ::std::move(from);
  }

 public:
  ::google::protobuf::Metadata GetMetadata() const final;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  // @@protoc_insertion_point(class_scope:tari.rpc.FlowInfo)
 private:
  class _Internal;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from);
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  friend struct ::TableStruct_sidechain_5ftypes_2eproto;
};
// -------------------------------------------------------------------

class ConfidentialOutputData final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:tari.rpc.ConfidentialOutputData) */ {
 public:
  inline ConfidentialOutputData() : ConfidentialOutputData(nullptr) {}
  ~ConfidentialOutputData() override;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR ConfidentialOutputData(
      ::google::protobuf::internal::ConstantInitialized);

  inline ConfidentialOutputData(const ConfidentialOutputData& from) : ConfidentialOutputData(nullptr, from) {}
  inline ConfidentialOutputData(ConfidentialOutputData&& from) noexcept
      : ConfidentialOutputData(nullptr, std::move(from)) {}
  inline ConfidentialOutputData& operator=(const ConfidentialOutputData& from) {
    CopyFrom(from);
    return *this;
  }
  inline ConfidentialOutputData& operator=(ConfidentialOutputData&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ConfidentialOutputData& default_instance() {
    return *internal_default_instance();
  }
  static inline const ConfidentialOutputData* internal_default_instance() {
    return reinterpret_cast<const ConfidentialOutputData*>(
        &_ConfidentialOutputData_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 3;
  friend void swap(ConfidentialOutputData& a, ConfidentialOutputData& b) { a.Swap(&b); }
  inline void Swap(ConfidentialOutputData* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ConfidentialOutputData* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ConfidentialOutputData* New(::google::protobuf::Arena* arena = nullptr) const final {
    return ::google::protobuf::Message::DefaultConstruct<ConfidentialOutputData>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const ConfidentialOutputData& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const ConfidentialOutputData& from) { ConfidentialOutputData::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(ConfidentialOutputData* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "tari.rpc.ConfidentialOutputData"; }

 protected:
  explicit ConfidentialOutputData(::google::protobuf::Arena* arena);
  ConfidentialOutputData(::google::protobuf::Arena* arena, const ConfidentialOutputData& from);
  ConfidentialOutputData(::google::protobuf::Arena* arena, ConfidentialOutputData&& from) noexcept
      : ConfidentialOutputData(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::MessageLite::ClassData* GetClassData()
      const final;

 public:
  ::google::protobuf::Metadata GetMetadata() const final;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kClaimPublicKeyFieldNumber = 1,
  };
  // bytes claim_public_key = 1;
  void clear_claim_public_key() ;
  const std::string& claim_public_key() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_claim_public_key(Arg_&& arg, Args_... args);
  std::string* mutable_claim_public_key();
  PROTOBUF_NODISCARD std::string* release_claim_public_key();
  void set_allocated_claim_public_key(std::string* value);

  private:
  const std::string& _internal_claim_public_key() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_claim_public_key(
      const std::string& value);
  std::string* _internal_mutable_claim_public_key();

  public:
  // @@protoc_insertion_point(class_scope:tari.rpc.ConfidentialOutputData)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 1, 0,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::ArenaStringPtr claim_public_key_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_sidechain_5ftypes_2eproto;
};
// -------------------------------------------------------------------

class BuildInfo final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:tari.rpc.BuildInfo) */ {
 public:
  inline BuildInfo() : BuildInfo(nullptr) {}
  ~BuildInfo() override;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR BuildInfo(
      ::google::protobuf::internal::ConstantInitialized);

  inline BuildInfo(const BuildInfo& from) : BuildInfo(nullptr, from) {}
  inline BuildInfo(BuildInfo&& from) noexcept
      : BuildInfo(nullptr, std::move(from)) {}
  inline BuildInfo& operator=(const BuildInfo& from) {
    CopyFrom(from);
    return *this;
  }
  inline BuildInfo& operator=(BuildInfo&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const BuildInfo& default_instance() {
    return *internal_default_instance();
  }
  static inline const BuildInfo* internal_default_instance() {
    return reinterpret_cast<const BuildInfo*>(
        &_BuildInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 8;
  friend void swap(BuildInfo& a, BuildInfo& b) { a.Swap(&b); }
  inline void Swap(BuildInfo* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(BuildInfo* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  BuildInfo* New(::google::protobuf::Arena* arena = nullptr) const final {
    return ::google::protobuf::Message::DefaultConstruct<BuildInfo>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const BuildInfo& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const BuildInfo& from) { BuildInfo::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(BuildInfo* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "tari.rpc.BuildInfo"; }

 protected:
  explicit BuildInfo(::google::protobuf::Arena* arena);
  BuildInfo(::google::protobuf::Arena* arena, const BuildInfo& from);
  BuildInfo(::google::protobuf::Arena* arena, BuildInfo&& from) noexcept
      : BuildInfo(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::MessageLite::ClassData* GetClassData()
      const final;

 public:
  ::google::protobuf::Metadata GetMetadata() const final;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kRepoUrlFieldNumber = 1,
    kCommitHashFieldNumber = 2,
  };
  // string repo_url = 1;
  void clear_repo_url() ;
  const std::string& repo_url() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_repo_url(Arg_&& arg, Args_... args);
  std::string* mutable_repo_url();
  PROTOBUF_NODISCARD std::string* release_repo_url();
  void set_allocated_repo_url(std::string* value);

  private:
  const std::string& _internal_repo_url() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_repo_url(
      const std::string& value);
  std::string* _internal_mutable_repo_url();

  public:
  // bytes commit_hash = 2;
  void clear_commit_hash() ;
  const std::string& commit_hash() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_commit_hash(Arg_&& arg, Args_... args);
  std::string* mutable_commit_hash();
  PROTOBUF_NODISCARD std::string* release_commit_hash();
  void set_allocated_commit_hash(std::string* value);

  private:
  const std::string& _internal_commit_hash() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_commit_hash(
      const std::string& value);
  std::string* _internal_mutable_commit_hash();

  public:
  // @@protoc_insertion_point(class_scope:tari.rpc.BuildInfo)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      1, 2, 0,
      35, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::ArenaStringPtr repo_url_;
    ::google::protobuf::internal::ArenaStringPtr commit_hash_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_sidechain_5ftypes_2eproto;
};
// -------------------------------------------------------------------

class ValidatorNodeRegistration final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:tari.rpc.ValidatorNodeRegistration) */ {
 public:
  inline ValidatorNodeRegistration() : ValidatorNodeRegistration(nullptr) {}
  ~ValidatorNodeRegistration() override;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR ValidatorNodeRegistration(
      ::google::protobuf::internal::ConstantInitialized);

  inline ValidatorNodeRegistration(const ValidatorNodeRegistration& from) : ValidatorNodeRegistration(nullptr, from) {}
  inline ValidatorNodeRegistration(ValidatorNodeRegistration&& from) noexcept
      : ValidatorNodeRegistration(nullptr, std::move(from)) {}
  inline ValidatorNodeRegistration& operator=(const ValidatorNodeRegistration& from) {
    CopyFrom(from);
    return *this;
  }
  inline ValidatorNodeRegistration& operator=(ValidatorNodeRegistration&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ValidatorNodeRegistration& default_instance() {
    return *internal_default_instance();
  }
  static inline const ValidatorNodeRegistration* internal_default_instance() {
    return reinterpret_cast<const ValidatorNodeRegistration*>(
        &_ValidatorNodeRegistration_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 1;
  friend void swap(ValidatorNodeRegistration& a, ValidatorNodeRegistration& b) { a.Swap(&b); }
  inline void Swap(ValidatorNodeRegistration* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ValidatorNodeRegistration* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ValidatorNodeRegistration* New(::google::protobuf::Arena* arena = nullptr) const final {
    return ::google::protobuf::Message::DefaultConstruct<ValidatorNodeRegistration>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const ValidatorNodeRegistration& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const ValidatorNodeRegistration& from) { ValidatorNodeRegistration::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(ValidatorNodeRegistration* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "tari.rpc.ValidatorNodeRegistration"; }

 protected:
  explicit ValidatorNodeRegistration(::google::protobuf::Arena* arena);
  ValidatorNodeRegistration(::google::protobuf::Arena* arena, const ValidatorNodeRegistration& from);
  ValidatorNodeRegistration(::google::protobuf::Arena* arena, ValidatorNodeRegistration&& from) noexcept
      : ValidatorNodeRegistration(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::MessageLite::ClassData* GetClassData()
      const final;

 public:
  ::google::protobuf::Metadata GetMetadata() const final;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kPublicKeyFieldNumber = 1,
    kSignatureFieldNumber = 2,
  };
  // bytes public_key = 1;
  void clear_public_key() ;
  const std::string& public_key() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_public_key(Arg_&& arg, Args_... args);
  std::string* mutable_public_key();
  PROTOBUF_NODISCARD std::string* release_public_key();
  void set_allocated_public_key(std::string* value);

  private:
  const std::string& _internal_public_key() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_public_key(
      const std::string& value);
  std::string* _internal_mutable_public_key();

  public:
  // .tari.rpc.Signature signature = 2;
  bool has_signature() const;
  void clear_signature() ;
  const ::tari::rpc::Signature& signature() const;
  PROTOBUF_NODISCARD ::tari::rpc::Signature* release_signature();
  ::tari::rpc::Signature* mutable_signature();
  void set_allocated_signature(::tari::rpc::Signature* value);
  void unsafe_arena_set_allocated_signature(::tari::rpc::Signature* value);
  ::tari::rpc::Signature* unsafe_arena_release_signature();

  private:
  const ::tari::rpc::Signature& _internal_signature() const;
  ::tari::rpc::Signature* _internal_mutable_signature();

  public:
  // @@protoc_insertion_point(class_scope:tari.rpc.ValidatorNodeRegistration)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      1, 2, 1,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::internal::ArenaStringPtr public_key_;
    ::tari::rpc::Signature* signature_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_sidechain_5ftypes_2eproto;
};
// -------------------------------------------------------------------

class TemplateType final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:tari.rpc.TemplateType) */ {
 public:
  inline TemplateType() : TemplateType(nullptr) {}
  ~TemplateType() override;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR TemplateType(
      ::google::protobuf::internal::ConstantInitialized);

  inline TemplateType(const TemplateType& from) : TemplateType(nullptr, from) {}
  inline TemplateType(TemplateType&& from) noexcept
      : TemplateType(nullptr, std::move(from)) {}
  inline TemplateType& operator=(const TemplateType& from) {
    CopyFrom(from);
    return *this;
  }
  inline TemplateType& operator=(TemplateType&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const TemplateType& default_instance() {
    return *internal_default_instance();
  }
  enum TemplateTypeCase {
    kWasm = 1,
    kFlow = 2,
    kManifest = 3,
    TEMPLATE_TYPE_NOT_SET = 0,
  };
  static inline const TemplateType* internal_default_instance() {
    return reinterpret_cast<const TemplateType*>(
        &_TemplateType_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 4;
  friend void swap(TemplateType& a, TemplateType& b) { a.Swap(&b); }
  inline void Swap(TemplateType* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TemplateType* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  TemplateType* New(::google::protobuf::Arena* arena = nullptr) const final {
    return ::google::protobuf::Message::DefaultConstruct<TemplateType>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const TemplateType& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const TemplateType& from) { TemplateType::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(TemplateType* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "tari.rpc.TemplateType"; }

 protected:
  explicit TemplateType(::google::protobuf::Arena* arena);
  TemplateType(::google::protobuf::Arena* arena, const TemplateType& from);
  TemplateType(::google::protobuf::Arena* arena, TemplateType&& from) noexcept
      : TemplateType(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::MessageLite::ClassData* GetClassData()
      const final;

 public:
  ::google::protobuf::Metadata GetMetadata() const final;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kWasmFieldNumber = 1,
    kFlowFieldNumber = 2,
    kManifestFieldNumber = 3,
  };
  // .tari.rpc.WasmInfo wasm = 1;
  bool has_wasm() const;
  private:
  bool _internal_has_wasm() const;

  public:
  void clear_wasm() ;
  const ::tari::rpc::WasmInfo& wasm() const;
  PROTOBUF_NODISCARD ::tari::rpc::WasmInfo* release_wasm();
  ::tari::rpc::WasmInfo* mutable_wasm();
  void set_allocated_wasm(::tari::rpc::WasmInfo* value);
  void unsafe_arena_set_allocated_wasm(::tari::rpc::WasmInfo* value);
  ::tari::rpc::WasmInfo* unsafe_arena_release_wasm();

  private:
  const ::tari::rpc::WasmInfo& _internal_wasm() const;
  ::tari::rpc::WasmInfo* _internal_mutable_wasm();

  public:
  // .tari.rpc.FlowInfo flow = 2;
  bool has_flow() const;
  private:
  bool _internal_has_flow() const;

  public:
  void clear_flow() ;
  const ::tari::rpc::FlowInfo& flow() const;
  PROTOBUF_NODISCARD ::tari::rpc::FlowInfo* release_flow();
  ::tari::rpc::FlowInfo* mutable_flow();
  void set_allocated_flow(::tari::rpc::FlowInfo* value);
  void unsafe_arena_set_allocated_flow(::tari::rpc::FlowInfo* value);
  ::tari::rpc::FlowInfo* unsafe_arena_release_flow();

  private:
  const ::tari::rpc::FlowInfo& _internal_flow() const;
  ::tari::rpc::FlowInfo* _internal_mutable_flow();

  public:
  // .tari.rpc.ManifestInfo manifest = 3;
  bool has_manifest() const;
  private:
  bool _internal_has_manifest() const;

  public:
  void clear_manifest() ;
  const ::tari::rpc::ManifestInfo& manifest() const;
  PROTOBUF_NODISCARD ::tari::rpc::ManifestInfo* release_manifest();
  ::tari::rpc::ManifestInfo* mutable_manifest();
  void set_allocated_manifest(::tari::rpc::ManifestInfo* value);
  void unsafe_arena_set_allocated_manifest(::tari::rpc::ManifestInfo* value);
  ::tari::rpc::ManifestInfo* unsafe_arena_release_manifest();

  private:
  const ::tari::rpc::ManifestInfo& _internal_manifest() const;
  ::tari::rpc::ManifestInfo* _internal_mutable_manifest();

  public:
  void clear_template_type();
  TemplateTypeCase template_type_case() const;
  // @@protoc_insertion_point(class_scope:tari.rpc.TemplateType)
 private:
  class _Internal;
  void set_has_wasm();
  void set_has_flow();
  void set_has_manifest();
  inline bool has_template_type() const;
  inline void clear_has_template_type();
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 3, 3,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from);
    union TemplateTypeUnion {
      constexpr TemplateTypeUnion() : _constinit_{} {}
      ::google::protobuf::internal::ConstantInitialized _constinit_;
      ::tari::rpc::WasmInfo* wasm_;
      ::tari::rpc::FlowInfo* flow_;
      ::tari::rpc::ManifestInfo* manifest_;
    } template_type_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::uint32_t _oneof_case_[1];
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_sidechain_5ftypes_2eproto;
};
// -------------------------------------------------------------------

class TemplateRegistration final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:tari.rpc.TemplateRegistration) */ {
 public:
  inline TemplateRegistration() : TemplateRegistration(nullptr) {}
  ~TemplateRegistration() override;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR TemplateRegistration(
      ::google::protobuf::internal::ConstantInitialized);

  inline TemplateRegistration(const TemplateRegistration& from) : TemplateRegistration(nullptr, from) {}
  inline TemplateRegistration(TemplateRegistration&& from) noexcept
      : TemplateRegistration(nullptr, std::move(from)) {}
  inline TemplateRegistration& operator=(const TemplateRegistration& from) {
    CopyFrom(from);
    return *this;
  }
  inline TemplateRegistration& operator=(TemplateRegistration&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const TemplateRegistration& default_instance() {
    return *internal_default_instance();
  }
  static inline const TemplateRegistration* internal_default_instance() {
    return reinterpret_cast<const TemplateRegistration*>(
        &_TemplateRegistration_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 2;
  friend void swap(TemplateRegistration& a, TemplateRegistration& b) { a.Swap(&b); }
  inline void Swap(TemplateRegistration* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TemplateRegistration* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  TemplateRegistration* New(::google::protobuf::Arena* arena = nullptr) const final {
    return ::google::protobuf::Message::DefaultConstruct<TemplateRegistration>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const TemplateRegistration& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const TemplateRegistration& from) { TemplateRegistration::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(TemplateRegistration* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "tari.rpc.TemplateRegistration"; }

 protected:
  explicit TemplateRegistration(::google::protobuf::Arena* arena);
  TemplateRegistration(::google::protobuf::Arena* arena, const TemplateRegistration& from);
  TemplateRegistration(::google::protobuf::Arena* arena, TemplateRegistration&& from) noexcept
      : TemplateRegistration(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::MessageLite::ClassData* GetClassData()
      const final;

 public:
  ::google::protobuf::Metadata GetMetadata() const final;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kAuthorPublicKeyFieldNumber = 1,
    kTemplateNameFieldNumber = 3,
    kBinaryShaFieldNumber = 7,
    kBinaryUrlFieldNumber = 8,
    kAuthorSignatureFieldNumber = 2,
    kTemplateTypeFieldNumber = 5,
    kBuildInfoFieldNumber = 6,
    kTemplateVersionFieldNumber = 4,
  };
  // bytes author_public_key = 1;
  void clear_author_public_key() ;
  const std::string& author_public_key() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_author_public_key(Arg_&& arg, Args_... args);
  std::string* mutable_author_public_key();
  PROTOBUF_NODISCARD std::string* release_author_public_key();
  void set_allocated_author_public_key(std::string* value);

  private:
  const std::string& _internal_author_public_key() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_author_public_key(
      const std::string& value);
  std::string* _internal_mutable_author_public_key();

  public:
  // string template_name = 3;
  void clear_template_name() ;
  const std::string& template_name() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_template_name(Arg_&& arg, Args_... args);
  std::string* mutable_template_name();
  PROTOBUF_NODISCARD std::string* release_template_name();
  void set_allocated_template_name(std::string* value);

  private:
  const std::string& _internal_template_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_template_name(
      const std::string& value);
  std::string* _internal_mutable_template_name();

  public:
  // bytes binary_sha = 7;
  void clear_binary_sha() ;
  const std::string& binary_sha() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_binary_sha(Arg_&& arg, Args_... args);
  std::string* mutable_binary_sha();
  PROTOBUF_NODISCARD std::string* release_binary_sha();
  void set_allocated_binary_sha(std::string* value);

  private:
  const std::string& _internal_binary_sha() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_binary_sha(
      const std::string& value);
  std::string* _internal_mutable_binary_sha();

  public:
  // string binary_url = 8;
  void clear_binary_url() ;
  const std::string& binary_url() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_binary_url(Arg_&& arg, Args_... args);
  std::string* mutable_binary_url();
  PROTOBUF_NODISCARD std::string* release_binary_url();
  void set_allocated_binary_url(std::string* value);

  private:
  const std::string& _internal_binary_url() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_binary_url(
      const std::string& value);
  std::string* _internal_mutable_binary_url();

  public:
  // .tari.rpc.Signature author_signature = 2;
  bool has_author_signature() const;
  void clear_author_signature() ;
  const ::tari::rpc::Signature& author_signature() const;
  PROTOBUF_NODISCARD ::tari::rpc::Signature* release_author_signature();
  ::tari::rpc::Signature* mutable_author_signature();
  void set_allocated_author_signature(::tari::rpc::Signature* value);
  void unsafe_arena_set_allocated_author_signature(::tari::rpc::Signature* value);
  ::tari::rpc::Signature* unsafe_arena_release_author_signature();

  private:
  const ::tari::rpc::Signature& _internal_author_signature() const;
  ::tari::rpc::Signature* _internal_mutable_author_signature();

  public:
  // .tari.rpc.TemplateType template_type = 5;
  bool has_template_type() const;
  void clear_template_type() ;
  const ::tari::rpc::TemplateType& template_type() const;
  PROTOBUF_NODISCARD ::tari::rpc::TemplateType* release_template_type();
  ::tari::rpc::TemplateType* mutable_template_type();
  void set_allocated_template_type(::tari::rpc::TemplateType* value);
  void unsafe_arena_set_allocated_template_type(::tari::rpc::TemplateType* value);
  ::tari::rpc::TemplateType* unsafe_arena_release_template_type();

  private:
  const ::tari::rpc::TemplateType& _internal_template_type() const;
  ::tari::rpc::TemplateType* _internal_mutable_template_type();

  public:
  // .tari.rpc.BuildInfo build_info = 6;
  bool has_build_info() const;
  void clear_build_info() ;
  const ::tari::rpc::BuildInfo& build_info() const;
  PROTOBUF_NODISCARD ::tari::rpc::BuildInfo* release_build_info();
  ::tari::rpc::BuildInfo* mutable_build_info();
  void set_allocated_build_info(::tari::rpc::BuildInfo* value);
  void unsafe_arena_set_allocated_build_info(::tari::rpc::BuildInfo* value);
  ::tari::rpc::BuildInfo* unsafe_arena_release_build_info();

  private:
  const ::tari::rpc::BuildInfo& _internal_build_info() const;
  ::tari::rpc::BuildInfo* _internal_mutable_build_info();

  public:
  // uint32 template_version = 4;
  void clear_template_version() ;
  ::uint32_t template_version() const;
  void set_template_version(::uint32_t value);

  private:
  ::uint32_t _internal_template_version() const;
  void _internal_set_template_version(::uint32_t value);

  public:
  // @@protoc_insertion_point(class_scope:tari.rpc.TemplateRegistration)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      3, 8, 3,
      69, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::internal::ArenaStringPtr author_public_key_;
    ::google::protobuf::internal::ArenaStringPtr template_name_;
    ::google::protobuf::internal::ArenaStringPtr binary_sha_;
    ::google::protobuf::internal::ArenaStringPtr binary_url_;
    ::tari::rpc::Signature* author_signature_;
    ::tari::rpc::TemplateType* template_type_;
    ::tari::rpc::BuildInfo* build_info_;
    ::uint32_t template_version_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_sidechain_5ftypes_2eproto;
};
// -------------------------------------------------------------------

class SideChainFeature final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:tari.rpc.SideChainFeature) */ {
 public:
  inline SideChainFeature() : SideChainFeature(nullptr) {}
  ~SideChainFeature() override;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR SideChainFeature(
      ::google::protobuf::internal::ConstantInitialized);

  inline SideChainFeature(const SideChainFeature& from) : SideChainFeature(nullptr, from) {}
  inline SideChainFeature(SideChainFeature&& from) noexcept
      : SideChainFeature(nullptr, std::move(from)) {}
  inline SideChainFeature& operator=(const SideChainFeature& from) {
    CopyFrom(from);
    return *this;
  }
  inline SideChainFeature& operator=(SideChainFeature&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SideChainFeature& default_instance() {
    return *internal_default_instance();
  }
  enum SideChainFeatureCase {
    kValidatorNodeRegistration = 1,
    kTemplateRegistration = 2,
    kConfidentialOutput = 3,
    SIDE_CHAIN_FEATURE_NOT_SET = 0,
  };
  static inline const SideChainFeature* internal_default_instance() {
    return reinterpret_cast<const SideChainFeature*>(
        &_SideChainFeature_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 0;
  friend void swap(SideChainFeature& a, SideChainFeature& b) { a.Swap(&b); }
  inline void Swap(SideChainFeature* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SideChainFeature* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SideChainFeature* New(::google::protobuf::Arena* arena = nullptr) const final {
    return ::google::protobuf::Message::DefaultConstruct<SideChainFeature>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const SideChainFeature& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const SideChainFeature& from) { SideChainFeature::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(SideChainFeature* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "tari.rpc.SideChainFeature"; }

 protected:
  explicit SideChainFeature(::google::protobuf::Arena* arena);
  SideChainFeature(::google::protobuf::Arena* arena, const SideChainFeature& from);
  SideChainFeature(::google::protobuf::Arena* arena, SideChainFeature&& from) noexcept
      : SideChainFeature(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::MessageLite::ClassData* GetClassData()
      const final;

 public:
  ::google::protobuf::Metadata GetMetadata() const final;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kValidatorNodeRegistrationFieldNumber = 1,
    kTemplateRegistrationFieldNumber = 2,
    kConfidentialOutputFieldNumber = 3,
  };
  // .tari.rpc.ValidatorNodeRegistration validator_node_registration = 1;
  bool has_validator_node_registration() const;
  private:
  bool _internal_has_validator_node_registration() const;

  public:
  void clear_validator_node_registration() ;
  const ::tari::rpc::ValidatorNodeRegistration& validator_node_registration() const;
  PROTOBUF_NODISCARD ::tari::rpc::ValidatorNodeRegistration* release_validator_node_registration();
  ::tari::rpc::ValidatorNodeRegistration* mutable_validator_node_registration();
  void set_allocated_validator_node_registration(::tari::rpc::ValidatorNodeRegistration* value);
  void unsafe_arena_set_allocated_validator_node_registration(::tari::rpc::ValidatorNodeRegistration* value);
  ::tari::rpc::ValidatorNodeRegistration* unsafe_arena_release_validator_node_registration();

  private:
  const ::tari::rpc::ValidatorNodeRegistration& _internal_validator_node_registration() const;
  ::tari::rpc::ValidatorNodeRegistration* _internal_mutable_validator_node_registration();

  public:
  // .tari.rpc.TemplateRegistration template_registration = 2;
  bool has_template_registration() const;
  private:
  bool _internal_has_template_registration() const;

  public:
  void clear_template_registration() ;
  const ::tari::rpc::TemplateRegistration& template_registration() const;
  PROTOBUF_NODISCARD ::tari::rpc::TemplateRegistration* release_template_registration();
  ::tari::rpc::TemplateRegistration* mutable_template_registration();
  void set_allocated_template_registration(::tari::rpc::TemplateRegistration* value);
  void unsafe_arena_set_allocated_template_registration(::tari::rpc::TemplateRegistration* value);
  ::tari::rpc::TemplateRegistration* unsafe_arena_release_template_registration();

  private:
  const ::tari::rpc::TemplateRegistration& _internal_template_registration() const;
  ::tari::rpc::TemplateRegistration* _internal_mutable_template_registration();

  public:
  // .tari.rpc.ConfidentialOutputData confidential_output = 3;
  bool has_confidential_output() const;
  private:
  bool _internal_has_confidential_output() const;

  public:
  void clear_confidential_output() ;
  const ::tari::rpc::ConfidentialOutputData& confidential_output() const;
  PROTOBUF_NODISCARD ::tari::rpc::ConfidentialOutputData* release_confidential_output();
  ::tari::rpc::ConfidentialOutputData* mutable_confidential_output();
  void set_allocated_confidential_output(::tari::rpc::ConfidentialOutputData* value);
  void unsafe_arena_set_allocated_confidential_output(::tari::rpc::ConfidentialOutputData* value);
  ::tari::rpc::ConfidentialOutputData* unsafe_arena_release_confidential_output();

  private:
  const ::tari::rpc::ConfidentialOutputData& _internal_confidential_output() const;
  ::tari::rpc::ConfidentialOutputData* _internal_mutable_confidential_output();

  public:
  void clear_side_chain_feature();
  SideChainFeatureCase side_chain_feature_case() const;
  // @@protoc_insertion_point(class_scope:tari.rpc.SideChainFeature)
 private:
  class _Internal;
  void set_has_validator_node_registration();
  void set_has_template_registration();
  void set_has_confidential_output();
  inline bool has_side_chain_feature() const;
  inline void clear_has_side_chain_feature();
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 3, 3,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from);
    union SideChainFeatureUnion {
      constexpr SideChainFeatureUnion() : _constinit_{} {}
      ::google::protobuf::internal::ConstantInitialized _constinit_;
      ::tari::rpc::ValidatorNodeRegistration* validator_node_registration_;
      ::tari::rpc::TemplateRegistration* template_registration_;
      ::tari::rpc::ConfidentialOutputData* confidential_output_;
    } side_chain_feature_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::uint32_t _oneof_case_[1];
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_sidechain_5ftypes_2eproto;
};

// ===================================================================




// ===================================================================


#ifdef __GNUC__
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// -------------------------------------------------------------------

// SideChainFeature

// .tari.rpc.ValidatorNodeRegistration validator_node_registration = 1;
inline bool SideChainFeature::has_validator_node_registration() const {
  return side_chain_feature_case() == kValidatorNodeRegistration;
}
inline bool SideChainFeature::_internal_has_validator_node_registration() const {
  return side_chain_feature_case() == kValidatorNodeRegistration;
}
inline void SideChainFeature::set_has_validator_node_registration() {
  _impl_._oneof_case_[0] = kValidatorNodeRegistration;
}
inline void SideChainFeature::clear_validator_node_registration() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (side_chain_feature_case() == kValidatorNodeRegistration) {
    if (GetArena() == nullptr) {
      delete _impl_.side_chain_feature_.validator_node_registration_;
    }
    clear_has_side_chain_feature();
  }
}
inline ::tari::rpc::ValidatorNodeRegistration* SideChainFeature::release_validator_node_registration() {
  // @@protoc_insertion_point(field_release:tari.rpc.SideChainFeature.validator_node_registration)
  if (side_chain_feature_case() == kValidatorNodeRegistration) {
    clear_has_side_chain_feature();
    auto* temp = _impl_.side_chain_feature_.validator_node_registration_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.side_chain_feature_.validator_node_registration_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::tari::rpc::ValidatorNodeRegistration& SideChainFeature::_internal_validator_node_registration() const {
  return side_chain_feature_case() == kValidatorNodeRegistration ? *_impl_.side_chain_feature_.validator_node_registration_ : reinterpret_cast<::tari::rpc::ValidatorNodeRegistration&>(::tari::rpc::_ValidatorNodeRegistration_default_instance_);
}
inline const ::tari::rpc::ValidatorNodeRegistration& SideChainFeature::validator_node_registration() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:tari.rpc.SideChainFeature.validator_node_registration)
  return _internal_validator_node_registration();
}
inline ::tari::rpc::ValidatorNodeRegistration* SideChainFeature::unsafe_arena_release_validator_node_registration() {
  // @@protoc_insertion_point(field_unsafe_arena_release:tari.rpc.SideChainFeature.validator_node_registration)
  if (side_chain_feature_case() == kValidatorNodeRegistration) {
    clear_has_side_chain_feature();
    auto* temp = _impl_.side_chain_feature_.validator_node_registration_;
    _impl_.side_chain_feature_.validator_node_registration_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void SideChainFeature::unsafe_arena_set_allocated_validator_node_registration(::tari::rpc::ValidatorNodeRegistration* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_side_chain_feature();
  if (value) {
    set_has_validator_node_registration();
    _impl_.side_chain_feature_.validator_node_registration_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:tari.rpc.SideChainFeature.validator_node_registration)
}
inline ::tari::rpc::ValidatorNodeRegistration* SideChainFeature::_internal_mutable_validator_node_registration() {
  if (side_chain_feature_case() != kValidatorNodeRegistration) {
    clear_side_chain_feature();
    set_has_validator_node_registration();
    _impl_.side_chain_feature_.validator_node_registration_ =
        ::google::protobuf::Message::DefaultConstruct<::tari::rpc::ValidatorNodeRegistration>(GetArena());
  }
  return _impl_.side_chain_feature_.validator_node_registration_;
}
inline ::tari::rpc::ValidatorNodeRegistration* SideChainFeature::mutable_validator_node_registration() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::tari::rpc::ValidatorNodeRegistration* _msg = _internal_mutable_validator_node_registration();
  // @@protoc_insertion_point(field_mutable:tari.rpc.SideChainFeature.validator_node_registration)
  return _msg;
}

// .tari.rpc.TemplateRegistration template_registration = 2;
inline bool SideChainFeature::has_template_registration() const {
  return side_chain_feature_case() == kTemplateRegistration;
}
inline bool SideChainFeature::_internal_has_template_registration() const {
  return side_chain_feature_case() == kTemplateRegistration;
}
inline void SideChainFeature::set_has_template_registration() {
  _impl_._oneof_case_[0] = kTemplateRegistration;
}
inline void SideChainFeature::clear_template_registration() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (side_chain_feature_case() == kTemplateRegistration) {
    if (GetArena() == nullptr) {
      delete _impl_.side_chain_feature_.template_registration_;
    }
    clear_has_side_chain_feature();
  }
}
inline ::tari::rpc::TemplateRegistration* SideChainFeature::release_template_registration() {
  // @@protoc_insertion_point(field_release:tari.rpc.SideChainFeature.template_registration)
  if (side_chain_feature_case() == kTemplateRegistration) {
    clear_has_side_chain_feature();
    auto* temp = _impl_.side_chain_feature_.template_registration_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.side_chain_feature_.template_registration_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::tari::rpc::TemplateRegistration& SideChainFeature::_internal_template_registration() const {
  return side_chain_feature_case() == kTemplateRegistration ? *_impl_.side_chain_feature_.template_registration_ : reinterpret_cast<::tari::rpc::TemplateRegistration&>(::tari::rpc::_TemplateRegistration_default_instance_);
}
inline const ::tari::rpc::TemplateRegistration& SideChainFeature::template_registration() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:tari.rpc.SideChainFeature.template_registration)
  return _internal_template_registration();
}
inline ::tari::rpc::TemplateRegistration* SideChainFeature::unsafe_arena_release_template_registration() {
  // @@protoc_insertion_point(field_unsafe_arena_release:tari.rpc.SideChainFeature.template_registration)
  if (side_chain_feature_case() == kTemplateRegistration) {
    clear_has_side_chain_feature();
    auto* temp = _impl_.side_chain_feature_.template_registration_;
    _impl_.side_chain_feature_.template_registration_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void SideChainFeature::unsafe_arena_set_allocated_template_registration(::tari::rpc::TemplateRegistration* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_side_chain_feature();
  if (value) {
    set_has_template_registration();
    _impl_.side_chain_feature_.template_registration_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:tari.rpc.SideChainFeature.template_registration)
}
inline ::tari::rpc::TemplateRegistration* SideChainFeature::_internal_mutable_template_registration() {
  if (side_chain_feature_case() != kTemplateRegistration) {
    clear_side_chain_feature();
    set_has_template_registration();
    _impl_.side_chain_feature_.template_registration_ =
        ::google::protobuf::Message::DefaultConstruct<::tari::rpc::TemplateRegistration>(GetArena());
  }
  return _impl_.side_chain_feature_.template_registration_;
}
inline ::tari::rpc::TemplateRegistration* SideChainFeature::mutable_template_registration() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::tari::rpc::TemplateRegistration* _msg = _internal_mutable_template_registration();
  // @@protoc_insertion_point(field_mutable:tari.rpc.SideChainFeature.template_registration)
  return _msg;
}

// .tari.rpc.ConfidentialOutputData confidential_output = 3;
inline bool SideChainFeature::has_confidential_output() const {
  return side_chain_feature_case() == kConfidentialOutput;
}
inline bool SideChainFeature::_internal_has_confidential_output() const {
  return side_chain_feature_case() == kConfidentialOutput;
}
inline void SideChainFeature::set_has_confidential_output() {
  _impl_._oneof_case_[0] = kConfidentialOutput;
}
inline void SideChainFeature::clear_confidential_output() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (side_chain_feature_case() == kConfidentialOutput) {
    if (GetArena() == nullptr) {
      delete _impl_.side_chain_feature_.confidential_output_;
    }
    clear_has_side_chain_feature();
  }
}
inline ::tari::rpc::ConfidentialOutputData* SideChainFeature::release_confidential_output() {
  // @@protoc_insertion_point(field_release:tari.rpc.SideChainFeature.confidential_output)
  if (side_chain_feature_case() == kConfidentialOutput) {
    clear_has_side_chain_feature();
    auto* temp = _impl_.side_chain_feature_.confidential_output_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.side_chain_feature_.confidential_output_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::tari::rpc::ConfidentialOutputData& SideChainFeature::_internal_confidential_output() const {
  return side_chain_feature_case() == kConfidentialOutput ? *_impl_.side_chain_feature_.confidential_output_ : reinterpret_cast<::tari::rpc::ConfidentialOutputData&>(::tari::rpc::_ConfidentialOutputData_default_instance_);
}
inline const ::tari::rpc::ConfidentialOutputData& SideChainFeature::confidential_output() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:tari.rpc.SideChainFeature.confidential_output)
  return _internal_confidential_output();
}
inline ::tari::rpc::ConfidentialOutputData* SideChainFeature::unsafe_arena_release_confidential_output() {
  // @@protoc_insertion_point(field_unsafe_arena_release:tari.rpc.SideChainFeature.confidential_output)
  if (side_chain_feature_case() == kConfidentialOutput) {
    clear_has_side_chain_feature();
    auto* temp = _impl_.side_chain_feature_.confidential_output_;
    _impl_.side_chain_feature_.confidential_output_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void SideChainFeature::unsafe_arena_set_allocated_confidential_output(::tari::rpc::ConfidentialOutputData* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_side_chain_feature();
  if (value) {
    set_has_confidential_output();
    _impl_.side_chain_feature_.confidential_output_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:tari.rpc.SideChainFeature.confidential_output)
}
inline ::tari::rpc::ConfidentialOutputData* SideChainFeature::_internal_mutable_confidential_output() {
  if (side_chain_feature_case() != kConfidentialOutput) {
    clear_side_chain_feature();
    set_has_confidential_output();
    _impl_.side_chain_feature_.confidential_output_ =
        ::google::protobuf::Message::DefaultConstruct<::tari::rpc::ConfidentialOutputData>(GetArena());
  }
  return _impl_.side_chain_feature_.confidential_output_;
}
inline ::tari::rpc::ConfidentialOutputData* SideChainFeature::mutable_confidential_output() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::tari::rpc::ConfidentialOutputData* _msg = _internal_mutable_confidential_output();
  // @@protoc_insertion_point(field_mutable:tari.rpc.SideChainFeature.confidential_output)
  return _msg;
}

inline bool SideChainFeature::has_side_chain_feature() const {
  return side_chain_feature_case() != SIDE_CHAIN_FEATURE_NOT_SET;
}
inline void SideChainFeature::clear_has_side_chain_feature() {
  _impl_._oneof_case_[0] = SIDE_CHAIN_FEATURE_NOT_SET;
}
inline SideChainFeature::SideChainFeatureCase SideChainFeature::side_chain_feature_case() const {
  return SideChainFeature::SideChainFeatureCase(_impl_._oneof_case_[0]);
}
// -------------------------------------------------------------------

// ValidatorNodeRegistration

// bytes public_key = 1;
inline void ValidatorNodeRegistration::clear_public_key() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.public_key_.ClearToEmpty();
}
inline const std::string& ValidatorNodeRegistration::public_key() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:tari.rpc.ValidatorNodeRegistration.public_key)
  return _internal_public_key();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void ValidatorNodeRegistration::set_public_key(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.public_key_.SetBytes(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:tari.rpc.ValidatorNodeRegistration.public_key)
}
inline std::string* ValidatorNodeRegistration::mutable_public_key() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_public_key();
  // @@protoc_insertion_point(field_mutable:tari.rpc.ValidatorNodeRegistration.public_key)
  return _s;
}
inline const std::string& ValidatorNodeRegistration::_internal_public_key() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.public_key_.Get();
}
inline void ValidatorNodeRegistration::_internal_set_public_key(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.public_key_.Set(value, GetArena());
}
inline std::string* ValidatorNodeRegistration::_internal_mutable_public_key() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _impl_.public_key_.Mutable( GetArena());
}
inline std::string* ValidatorNodeRegistration::release_public_key() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:tari.rpc.ValidatorNodeRegistration.public_key)
  return _impl_.public_key_.Release();
}
inline void ValidatorNodeRegistration::set_allocated_public_key(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.public_key_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.public_key_.IsDefault()) {
          _impl_.public_key_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:tari.rpc.ValidatorNodeRegistration.public_key)
}

// .tari.rpc.Signature signature = 2;
inline bool ValidatorNodeRegistration::has_signature() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.signature_ != nullptr);
  return value;
}
inline const ::tari::rpc::Signature& ValidatorNodeRegistration::_internal_signature() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::tari::rpc::Signature* p = _impl_.signature_;
  return p != nullptr ? *p : reinterpret_cast<const ::tari::rpc::Signature&>(::tari::rpc::_Signature_default_instance_);
}
inline const ::tari::rpc::Signature& ValidatorNodeRegistration::signature() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:tari.rpc.ValidatorNodeRegistration.signature)
  return _internal_signature();
}
inline void ValidatorNodeRegistration::unsafe_arena_set_allocated_signature(::tari::rpc::Signature* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.signature_);
  }
  _impl_.signature_ = reinterpret_cast<::tari::rpc::Signature*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:tari.rpc.ValidatorNodeRegistration.signature)
}
inline ::tari::rpc::Signature* ValidatorNodeRegistration::release_signature() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::tari::rpc::Signature* released = _impl_.signature_;
  _impl_.signature_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::tari::rpc::Signature* ValidatorNodeRegistration::unsafe_arena_release_signature() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:tari.rpc.ValidatorNodeRegistration.signature)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::tari::rpc::Signature* temp = _impl_.signature_;
  _impl_.signature_ = nullptr;
  return temp;
}
inline ::tari::rpc::Signature* ValidatorNodeRegistration::_internal_mutable_signature() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.signature_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::tari::rpc::Signature>(GetArena());
    _impl_.signature_ = reinterpret_cast<::tari::rpc::Signature*>(p);
  }
  return _impl_.signature_;
}
inline ::tari::rpc::Signature* ValidatorNodeRegistration::mutable_signature() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000001u;
  ::tari::rpc::Signature* _msg = _internal_mutable_signature();
  // @@protoc_insertion_point(field_mutable:tari.rpc.ValidatorNodeRegistration.signature)
  return _msg;
}
inline void ValidatorNodeRegistration::set_allocated_signature(::tari::rpc::Signature* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.signature_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::MessageLite*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.signature_ = reinterpret_cast<::tari::rpc::Signature*>(value);
  // @@protoc_insertion_point(field_set_allocated:tari.rpc.ValidatorNodeRegistration.signature)
}

// -------------------------------------------------------------------

// TemplateRegistration

// bytes author_public_key = 1;
inline void TemplateRegistration::clear_author_public_key() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.author_public_key_.ClearToEmpty();
}
inline const std::string& TemplateRegistration::author_public_key() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:tari.rpc.TemplateRegistration.author_public_key)
  return _internal_author_public_key();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void TemplateRegistration::set_author_public_key(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.author_public_key_.SetBytes(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:tari.rpc.TemplateRegistration.author_public_key)
}
inline std::string* TemplateRegistration::mutable_author_public_key() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_author_public_key();
  // @@protoc_insertion_point(field_mutable:tari.rpc.TemplateRegistration.author_public_key)
  return _s;
}
inline const std::string& TemplateRegistration::_internal_author_public_key() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.author_public_key_.Get();
}
inline void TemplateRegistration::_internal_set_author_public_key(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.author_public_key_.Set(value, GetArena());
}
inline std::string* TemplateRegistration::_internal_mutable_author_public_key() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _impl_.author_public_key_.Mutable( GetArena());
}
inline std::string* TemplateRegistration::release_author_public_key() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:tari.rpc.TemplateRegistration.author_public_key)
  return _impl_.author_public_key_.Release();
}
inline void TemplateRegistration::set_allocated_author_public_key(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.author_public_key_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.author_public_key_.IsDefault()) {
          _impl_.author_public_key_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:tari.rpc.TemplateRegistration.author_public_key)
}

// .tari.rpc.Signature author_signature = 2;
inline bool TemplateRegistration::has_author_signature() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.author_signature_ != nullptr);
  return value;
}
inline const ::tari::rpc::Signature& TemplateRegistration::_internal_author_signature() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::tari::rpc::Signature* p = _impl_.author_signature_;
  return p != nullptr ? *p : reinterpret_cast<const ::tari::rpc::Signature&>(::tari::rpc::_Signature_default_instance_);
}
inline const ::tari::rpc::Signature& TemplateRegistration::author_signature() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:tari.rpc.TemplateRegistration.author_signature)
  return _internal_author_signature();
}
inline void TemplateRegistration::unsafe_arena_set_allocated_author_signature(::tari::rpc::Signature* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.author_signature_);
  }
  _impl_.author_signature_ = reinterpret_cast<::tari::rpc::Signature*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:tari.rpc.TemplateRegistration.author_signature)
}
inline ::tari::rpc::Signature* TemplateRegistration::release_author_signature() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::tari::rpc::Signature* released = _impl_.author_signature_;
  _impl_.author_signature_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::tari::rpc::Signature* TemplateRegistration::unsafe_arena_release_author_signature() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:tari.rpc.TemplateRegistration.author_signature)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::tari::rpc::Signature* temp = _impl_.author_signature_;
  _impl_.author_signature_ = nullptr;
  return temp;
}
inline ::tari::rpc::Signature* TemplateRegistration::_internal_mutable_author_signature() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.author_signature_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::tari::rpc::Signature>(GetArena());
    _impl_.author_signature_ = reinterpret_cast<::tari::rpc::Signature*>(p);
  }
  return _impl_.author_signature_;
}
inline ::tari::rpc::Signature* TemplateRegistration::mutable_author_signature() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000001u;
  ::tari::rpc::Signature* _msg = _internal_mutable_author_signature();
  // @@protoc_insertion_point(field_mutable:tari.rpc.TemplateRegistration.author_signature)
  return _msg;
}
inline void TemplateRegistration::set_allocated_author_signature(::tari::rpc::Signature* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.author_signature_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::MessageLite*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.author_signature_ = reinterpret_cast<::tari::rpc::Signature*>(value);
  // @@protoc_insertion_point(field_set_allocated:tari.rpc.TemplateRegistration.author_signature)
}

// string template_name = 3;
inline void TemplateRegistration::clear_template_name() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.template_name_.ClearToEmpty();
}
inline const std::string& TemplateRegistration::template_name() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:tari.rpc.TemplateRegistration.template_name)
  return _internal_template_name();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void TemplateRegistration::set_template_name(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.template_name_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:tari.rpc.TemplateRegistration.template_name)
}
inline std::string* TemplateRegistration::mutable_template_name() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_template_name();
  // @@protoc_insertion_point(field_mutable:tari.rpc.TemplateRegistration.template_name)
  return _s;
}
inline const std::string& TemplateRegistration::_internal_template_name() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.template_name_.Get();
}
inline void TemplateRegistration::_internal_set_template_name(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.template_name_.Set(value, GetArena());
}
inline std::string* TemplateRegistration::_internal_mutable_template_name() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _impl_.template_name_.Mutable( GetArena());
}
inline std::string* TemplateRegistration::release_template_name() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:tari.rpc.TemplateRegistration.template_name)
  return _impl_.template_name_.Release();
}
inline void TemplateRegistration::set_allocated_template_name(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.template_name_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.template_name_.IsDefault()) {
          _impl_.template_name_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:tari.rpc.TemplateRegistration.template_name)
}

// uint32 template_version = 4;
inline void TemplateRegistration::clear_template_version() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.template_version_ = 0u;
}
inline ::uint32_t TemplateRegistration::template_version() const {
  // @@protoc_insertion_point(field_get:tari.rpc.TemplateRegistration.template_version)
  return _internal_template_version();
}
inline void TemplateRegistration::set_template_version(::uint32_t value) {
  _internal_set_template_version(value);
  // @@protoc_insertion_point(field_set:tari.rpc.TemplateRegistration.template_version)
}
inline ::uint32_t TemplateRegistration::_internal_template_version() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.template_version_;
}
inline void TemplateRegistration::_internal_set_template_version(::uint32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.template_version_ = value;
}

// .tari.rpc.TemplateType template_type = 5;
inline bool TemplateRegistration::has_template_type() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.template_type_ != nullptr);
  return value;
}
inline void TemplateRegistration::clear_template_type() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.template_type_ != nullptr) _impl_.template_type_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const ::tari::rpc::TemplateType& TemplateRegistration::_internal_template_type() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::tari::rpc::TemplateType* p = _impl_.template_type_;
  return p != nullptr ? *p : reinterpret_cast<const ::tari::rpc::TemplateType&>(::tari::rpc::_TemplateType_default_instance_);
}
inline const ::tari::rpc::TemplateType& TemplateRegistration::template_type() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:tari.rpc.TemplateRegistration.template_type)
  return _internal_template_type();
}
inline void TemplateRegistration::unsafe_arena_set_allocated_template_type(::tari::rpc::TemplateType* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.template_type_);
  }
  _impl_.template_type_ = reinterpret_cast<::tari::rpc::TemplateType*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:tari.rpc.TemplateRegistration.template_type)
}
inline ::tari::rpc::TemplateType* TemplateRegistration::release_template_type() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::tari::rpc::TemplateType* released = _impl_.template_type_;
  _impl_.template_type_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::tari::rpc::TemplateType* TemplateRegistration::unsafe_arena_release_template_type() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:tari.rpc.TemplateRegistration.template_type)

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::tari::rpc::TemplateType* temp = _impl_.template_type_;
  _impl_.template_type_ = nullptr;
  return temp;
}
inline ::tari::rpc::TemplateType* TemplateRegistration::_internal_mutable_template_type() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.template_type_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::tari::rpc::TemplateType>(GetArena());
    _impl_.template_type_ = reinterpret_cast<::tari::rpc::TemplateType*>(p);
  }
  return _impl_.template_type_;
}
inline ::tari::rpc::TemplateType* TemplateRegistration::mutable_template_type() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000002u;
  ::tari::rpc::TemplateType* _msg = _internal_mutable_template_type();
  // @@protoc_insertion_point(field_mutable:tari.rpc.TemplateRegistration.template_type)
  return _msg;
}
inline void TemplateRegistration::set_allocated_template_type(::tari::rpc::TemplateType* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete (_impl_.template_type_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = (value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }

  _impl_.template_type_ = reinterpret_cast<::tari::rpc::TemplateType*>(value);
  // @@protoc_insertion_point(field_set_allocated:tari.rpc.TemplateRegistration.template_type)
}

// .tari.rpc.BuildInfo build_info = 6;
inline bool TemplateRegistration::has_build_info() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.build_info_ != nullptr);
  return value;
}
inline void TemplateRegistration::clear_build_info() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.build_info_ != nullptr) _impl_.build_info_->Clear();
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline const ::tari::rpc::BuildInfo& TemplateRegistration::_internal_build_info() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::tari::rpc::BuildInfo* p = _impl_.build_info_;
  return p != nullptr ? *p : reinterpret_cast<const ::tari::rpc::BuildInfo&>(::tari::rpc::_BuildInfo_default_instance_);
}
inline const ::tari::rpc::BuildInfo& TemplateRegistration::build_info() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:tari.rpc.TemplateRegistration.build_info)
  return _internal_build_info();
}
inline void TemplateRegistration::unsafe_arena_set_allocated_build_info(::tari::rpc::BuildInfo* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.build_info_);
  }
  _impl_.build_info_ = reinterpret_cast<::tari::rpc::BuildInfo*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:tari.rpc.TemplateRegistration.build_info)
}
inline ::tari::rpc::BuildInfo* TemplateRegistration::release_build_info() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000004u;
  ::tari::rpc::BuildInfo* released = _impl_.build_info_;
  _impl_.build_info_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::tari::rpc::BuildInfo* TemplateRegistration::unsafe_arena_release_build_info() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:tari.rpc.TemplateRegistration.build_info)

  _impl_._has_bits_[0] &= ~0x00000004u;
  ::tari::rpc::BuildInfo* temp = _impl_.build_info_;
  _impl_.build_info_ = nullptr;
  return temp;
}
inline ::tari::rpc::BuildInfo* TemplateRegistration::_internal_mutable_build_info() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.build_info_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::tari::rpc::BuildInfo>(GetArena());
    _impl_.build_info_ = reinterpret_cast<::tari::rpc::BuildInfo*>(p);
  }
  return _impl_.build_info_;
}
inline ::tari::rpc::BuildInfo* TemplateRegistration::mutable_build_info() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000004u;
  ::tari::rpc::BuildInfo* _msg = _internal_mutable_build_info();
  // @@protoc_insertion_point(field_mutable:tari.rpc.TemplateRegistration.build_info)
  return _msg;
}
inline void TemplateRegistration::set_allocated_build_info(::tari::rpc::BuildInfo* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete (_impl_.build_info_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = (value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }

  _impl_.build_info_ = reinterpret_cast<::tari::rpc::BuildInfo*>(value);
  // @@protoc_insertion_point(field_set_allocated:tari.rpc.TemplateRegistration.build_info)
}

// bytes binary_sha = 7;
inline void TemplateRegistration::clear_binary_sha() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.binary_sha_.ClearToEmpty();
}
inline const std::string& TemplateRegistration::binary_sha() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:tari.rpc.TemplateRegistration.binary_sha)
  return _internal_binary_sha();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void TemplateRegistration::set_binary_sha(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.binary_sha_.SetBytes(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:tari.rpc.TemplateRegistration.binary_sha)
}
inline std::string* TemplateRegistration::mutable_binary_sha() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_binary_sha();
  // @@protoc_insertion_point(field_mutable:tari.rpc.TemplateRegistration.binary_sha)
  return _s;
}
inline const std::string& TemplateRegistration::_internal_binary_sha() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.binary_sha_.Get();
}
inline void TemplateRegistration::_internal_set_binary_sha(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.binary_sha_.Set(value, GetArena());
}
inline std::string* TemplateRegistration::_internal_mutable_binary_sha() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _impl_.binary_sha_.Mutable( GetArena());
}
inline std::string* TemplateRegistration::release_binary_sha() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:tari.rpc.TemplateRegistration.binary_sha)
  return _impl_.binary_sha_.Release();
}
inline void TemplateRegistration::set_allocated_binary_sha(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.binary_sha_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.binary_sha_.IsDefault()) {
          _impl_.binary_sha_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:tari.rpc.TemplateRegistration.binary_sha)
}

// string binary_url = 8;
inline void TemplateRegistration::clear_binary_url() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.binary_url_.ClearToEmpty();
}
inline const std::string& TemplateRegistration::binary_url() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:tari.rpc.TemplateRegistration.binary_url)
  return _internal_binary_url();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void TemplateRegistration::set_binary_url(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.binary_url_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:tari.rpc.TemplateRegistration.binary_url)
}
inline std::string* TemplateRegistration::mutable_binary_url() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_binary_url();
  // @@protoc_insertion_point(field_mutable:tari.rpc.TemplateRegistration.binary_url)
  return _s;
}
inline const std::string& TemplateRegistration::_internal_binary_url() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.binary_url_.Get();
}
inline void TemplateRegistration::_internal_set_binary_url(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.binary_url_.Set(value, GetArena());
}
inline std::string* TemplateRegistration::_internal_mutable_binary_url() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _impl_.binary_url_.Mutable( GetArena());
}
inline std::string* TemplateRegistration::release_binary_url() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:tari.rpc.TemplateRegistration.binary_url)
  return _impl_.binary_url_.Release();
}
inline void TemplateRegistration::set_allocated_binary_url(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.binary_url_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.binary_url_.IsDefault()) {
          _impl_.binary_url_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:tari.rpc.TemplateRegistration.binary_url)
}

// -------------------------------------------------------------------

// ConfidentialOutputData

// bytes claim_public_key = 1;
inline void ConfidentialOutputData::clear_claim_public_key() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.claim_public_key_.ClearToEmpty();
}
inline const std::string& ConfidentialOutputData::claim_public_key() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:tari.rpc.ConfidentialOutputData.claim_public_key)
  return _internal_claim_public_key();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void ConfidentialOutputData::set_claim_public_key(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.claim_public_key_.SetBytes(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:tari.rpc.ConfidentialOutputData.claim_public_key)
}
inline std::string* ConfidentialOutputData::mutable_claim_public_key() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_claim_public_key();
  // @@protoc_insertion_point(field_mutable:tari.rpc.ConfidentialOutputData.claim_public_key)
  return _s;
}
inline const std::string& ConfidentialOutputData::_internal_claim_public_key() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.claim_public_key_.Get();
}
inline void ConfidentialOutputData::_internal_set_claim_public_key(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.claim_public_key_.Set(value, GetArena());
}
inline std::string* ConfidentialOutputData::_internal_mutable_claim_public_key() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _impl_.claim_public_key_.Mutable( GetArena());
}
inline std::string* ConfidentialOutputData::release_claim_public_key() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:tari.rpc.ConfidentialOutputData.claim_public_key)
  return _impl_.claim_public_key_.Release();
}
inline void ConfidentialOutputData::set_allocated_claim_public_key(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.claim_public_key_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.claim_public_key_.IsDefault()) {
          _impl_.claim_public_key_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:tari.rpc.ConfidentialOutputData.claim_public_key)
}

// -------------------------------------------------------------------

// TemplateType

// .tari.rpc.WasmInfo wasm = 1;
inline bool TemplateType::has_wasm() const {
  return template_type_case() == kWasm;
}
inline bool TemplateType::_internal_has_wasm() const {
  return template_type_case() == kWasm;
}
inline void TemplateType::set_has_wasm() {
  _impl_._oneof_case_[0] = kWasm;
}
inline void TemplateType::clear_wasm() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (template_type_case() == kWasm) {
    if (GetArena() == nullptr) {
      delete _impl_.template_type_.wasm_;
    }
    clear_has_template_type();
  }
}
inline ::tari::rpc::WasmInfo* TemplateType::release_wasm() {
  // @@protoc_insertion_point(field_release:tari.rpc.TemplateType.wasm)
  if (template_type_case() == kWasm) {
    clear_has_template_type();
    auto* temp = _impl_.template_type_.wasm_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.template_type_.wasm_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::tari::rpc::WasmInfo& TemplateType::_internal_wasm() const {
  return template_type_case() == kWasm ? *_impl_.template_type_.wasm_ : reinterpret_cast<::tari::rpc::WasmInfo&>(::tari::rpc::_WasmInfo_default_instance_);
}
inline const ::tari::rpc::WasmInfo& TemplateType::wasm() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:tari.rpc.TemplateType.wasm)
  return _internal_wasm();
}
inline ::tari::rpc::WasmInfo* TemplateType::unsafe_arena_release_wasm() {
  // @@protoc_insertion_point(field_unsafe_arena_release:tari.rpc.TemplateType.wasm)
  if (template_type_case() == kWasm) {
    clear_has_template_type();
    auto* temp = _impl_.template_type_.wasm_;
    _impl_.template_type_.wasm_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void TemplateType::unsafe_arena_set_allocated_wasm(::tari::rpc::WasmInfo* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_template_type();
  if (value) {
    set_has_wasm();
    _impl_.template_type_.wasm_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:tari.rpc.TemplateType.wasm)
}
inline ::tari::rpc::WasmInfo* TemplateType::_internal_mutable_wasm() {
  if (template_type_case() != kWasm) {
    clear_template_type();
    set_has_wasm();
    _impl_.template_type_.wasm_ =
        ::google::protobuf::Message::DefaultConstruct<::tari::rpc::WasmInfo>(GetArena());
  }
  return _impl_.template_type_.wasm_;
}
inline ::tari::rpc::WasmInfo* TemplateType::mutable_wasm() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::tari::rpc::WasmInfo* _msg = _internal_mutable_wasm();
  // @@protoc_insertion_point(field_mutable:tari.rpc.TemplateType.wasm)
  return _msg;
}

// .tari.rpc.FlowInfo flow = 2;
inline bool TemplateType::has_flow() const {
  return template_type_case() == kFlow;
}
inline bool TemplateType::_internal_has_flow() const {
  return template_type_case() == kFlow;
}
inline void TemplateType::set_has_flow() {
  _impl_._oneof_case_[0] = kFlow;
}
inline void TemplateType::clear_flow() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (template_type_case() == kFlow) {
    if (GetArena() == nullptr) {
      delete _impl_.template_type_.flow_;
    }
    clear_has_template_type();
  }
}
inline ::tari::rpc::FlowInfo* TemplateType::release_flow() {
  // @@protoc_insertion_point(field_release:tari.rpc.TemplateType.flow)
  if (template_type_case() == kFlow) {
    clear_has_template_type();
    auto* temp = _impl_.template_type_.flow_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.template_type_.flow_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::tari::rpc::FlowInfo& TemplateType::_internal_flow() const {
  return template_type_case() == kFlow ? *_impl_.template_type_.flow_ : reinterpret_cast<::tari::rpc::FlowInfo&>(::tari::rpc::_FlowInfo_default_instance_);
}
inline const ::tari::rpc::FlowInfo& TemplateType::flow() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:tari.rpc.TemplateType.flow)
  return _internal_flow();
}
inline ::tari::rpc::FlowInfo* TemplateType::unsafe_arena_release_flow() {
  // @@protoc_insertion_point(field_unsafe_arena_release:tari.rpc.TemplateType.flow)
  if (template_type_case() == kFlow) {
    clear_has_template_type();
    auto* temp = _impl_.template_type_.flow_;
    _impl_.template_type_.flow_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void TemplateType::unsafe_arena_set_allocated_flow(::tari::rpc::FlowInfo* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_template_type();
  if (value) {
    set_has_flow();
    _impl_.template_type_.flow_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:tari.rpc.TemplateType.flow)
}
inline ::tari::rpc::FlowInfo* TemplateType::_internal_mutable_flow() {
  if (template_type_case() != kFlow) {
    clear_template_type();
    set_has_flow();
    _impl_.template_type_.flow_ =
        ::google::protobuf::Message::DefaultConstruct<::tari::rpc::FlowInfo>(GetArena());
  }
  return _impl_.template_type_.flow_;
}
inline ::tari::rpc::FlowInfo* TemplateType::mutable_flow() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::tari::rpc::FlowInfo* _msg = _internal_mutable_flow();
  // @@protoc_insertion_point(field_mutable:tari.rpc.TemplateType.flow)
  return _msg;
}

// .tari.rpc.ManifestInfo manifest = 3;
inline bool TemplateType::has_manifest() const {
  return template_type_case() == kManifest;
}
inline bool TemplateType::_internal_has_manifest() const {
  return template_type_case() == kManifest;
}
inline void TemplateType::set_has_manifest() {
  _impl_._oneof_case_[0] = kManifest;
}
inline void TemplateType::clear_manifest() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (template_type_case() == kManifest) {
    if (GetArena() == nullptr) {
      delete _impl_.template_type_.manifest_;
    }
    clear_has_template_type();
  }
}
inline ::tari::rpc::ManifestInfo* TemplateType::release_manifest() {
  // @@protoc_insertion_point(field_release:tari.rpc.TemplateType.manifest)
  if (template_type_case() == kManifest) {
    clear_has_template_type();
    auto* temp = _impl_.template_type_.manifest_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.template_type_.manifest_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::tari::rpc::ManifestInfo& TemplateType::_internal_manifest() const {
  return template_type_case() == kManifest ? *_impl_.template_type_.manifest_ : reinterpret_cast<::tari::rpc::ManifestInfo&>(::tari::rpc::_ManifestInfo_default_instance_);
}
inline const ::tari::rpc::ManifestInfo& TemplateType::manifest() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:tari.rpc.TemplateType.manifest)
  return _internal_manifest();
}
inline ::tari::rpc::ManifestInfo* TemplateType::unsafe_arena_release_manifest() {
  // @@protoc_insertion_point(field_unsafe_arena_release:tari.rpc.TemplateType.manifest)
  if (template_type_case() == kManifest) {
    clear_has_template_type();
    auto* temp = _impl_.template_type_.manifest_;
    _impl_.template_type_.manifest_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void TemplateType::unsafe_arena_set_allocated_manifest(::tari::rpc::ManifestInfo* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_template_type();
  if (value) {
    set_has_manifest();
    _impl_.template_type_.manifest_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:tari.rpc.TemplateType.manifest)
}
inline ::tari::rpc::ManifestInfo* TemplateType::_internal_mutable_manifest() {
  if (template_type_case() != kManifest) {
    clear_template_type();
    set_has_manifest();
    _impl_.template_type_.manifest_ =
        ::google::protobuf::Message::DefaultConstruct<::tari::rpc::ManifestInfo>(GetArena());
  }
  return _impl_.template_type_.manifest_;
}
inline ::tari::rpc::ManifestInfo* TemplateType::mutable_manifest() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::tari::rpc::ManifestInfo* _msg = _internal_mutable_manifest();
  // @@protoc_insertion_point(field_mutable:tari.rpc.TemplateType.manifest)
  return _msg;
}

inline bool TemplateType::has_template_type() const {
  return template_type_case() != TEMPLATE_TYPE_NOT_SET;
}
inline void TemplateType::clear_has_template_type() {
  _impl_._oneof_case_[0] = TEMPLATE_TYPE_NOT_SET;
}
inline TemplateType::TemplateTypeCase TemplateType::template_type_case() const {
  return TemplateType::TemplateTypeCase(_impl_._oneof_case_[0]);
}
// -------------------------------------------------------------------

// WasmInfo

// uint32 abi_version = 1;
inline void WasmInfo::clear_abi_version() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.abi_version_ = 0u;
}
inline ::uint32_t WasmInfo::abi_version() const {
  // @@protoc_insertion_point(field_get:tari.rpc.WasmInfo.abi_version)
  return _internal_abi_version();
}
inline void WasmInfo::set_abi_version(::uint32_t value) {
  _internal_set_abi_version(value);
  // @@protoc_insertion_point(field_set:tari.rpc.WasmInfo.abi_version)
}
inline ::uint32_t WasmInfo::_internal_abi_version() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.abi_version_;
}
inline void WasmInfo::_internal_set_abi_version(::uint32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.abi_version_ = value;
}

// -------------------------------------------------------------------

// FlowInfo

// -------------------------------------------------------------------

// ManifestInfo

// -------------------------------------------------------------------

// BuildInfo

// string repo_url = 1;
inline void BuildInfo::clear_repo_url() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.repo_url_.ClearToEmpty();
}
inline const std::string& BuildInfo::repo_url() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:tari.rpc.BuildInfo.repo_url)
  return _internal_repo_url();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void BuildInfo::set_repo_url(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.repo_url_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:tari.rpc.BuildInfo.repo_url)
}
inline std::string* BuildInfo::mutable_repo_url() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_repo_url();
  // @@protoc_insertion_point(field_mutable:tari.rpc.BuildInfo.repo_url)
  return _s;
}
inline const std::string& BuildInfo::_internal_repo_url() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.repo_url_.Get();
}
inline void BuildInfo::_internal_set_repo_url(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.repo_url_.Set(value, GetArena());
}
inline std::string* BuildInfo::_internal_mutable_repo_url() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _impl_.repo_url_.Mutable( GetArena());
}
inline std::string* BuildInfo::release_repo_url() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:tari.rpc.BuildInfo.repo_url)
  return _impl_.repo_url_.Release();
}
inline void BuildInfo::set_allocated_repo_url(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.repo_url_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.repo_url_.IsDefault()) {
          _impl_.repo_url_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:tari.rpc.BuildInfo.repo_url)
}

// bytes commit_hash = 2;
inline void BuildInfo::clear_commit_hash() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.commit_hash_.ClearToEmpty();
}
inline const std::string& BuildInfo::commit_hash() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:tari.rpc.BuildInfo.commit_hash)
  return _internal_commit_hash();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void BuildInfo::set_commit_hash(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.commit_hash_.SetBytes(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:tari.rpc.BuildInfo.commit_hash)
}
inline std::string* BuildInfo::mutable_commit_hash() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_commit_hash();
  // @@protoc_insertion_point(field_mutable:tari.rpc.BuildInfo.commit_hash)
  return _s;
}
inline const std::string& BuildInfo::_internal_commit_hash() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.commit_hash_.Get();
}
inline void BuildInfo::_internal_set_commit_hash(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.commit_hash_.Set(value, GetArena());
}
inline std::string* BuildInfo::_internal_mutable_commit_hash() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _impl_.commit_hash_.Mutable( GetArena());
}
inline std::string* BuildInfo::release_commit_hash() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:tari.rpc.BuildInfo.commit_hash)
  return _impl_.commit_hash_.Release();
}
inline void BuildInfo::set_allocated_commit_hash(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.commit_hash_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.commit_hash_.IsDefault()) {
          _impl_.commit_hash_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:tari.rpc.BuildInfo.commit_hash)
}

#ifdef __GNUC__
#pragma GCC diagnostic pop
#endif  // __GNUC__

// @@protoc_insertion_point(namespace_scope)
}  // namespace rpc
}  // namespace tari


// @@protoc_insertion_point(global_scope)

#include "google/protobuf/port_undef.inc"

#endif  // GOOGLE_PROTOBUF_INCLUDED_sidechain_5ftypes_2eproto_2epb_2eh
