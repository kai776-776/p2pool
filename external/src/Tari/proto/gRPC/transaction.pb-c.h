/* Generated by the protocol buffer compiler.  DO NOT EDIT! */
/* Generated from: transaction.proto */

#ifndef PROTOBUF_C_transaction_2eproto__INCLUDED
#define PROTOBUF_C_transaction_2eproto__INCLUDED

#include <protobuf-c/protobuf-c.h>

PROTOBUF_C__BEGIN_DECLS

#if PROTOBUF_C_VERSION_NUMBER < 1003000
# error This file was generated by a newer version of protoc-c which is incompatible with your libprotobuf-c headers. Please update your headers.
#elif 1003003 < PROTOBUF_C_MIN_COMPILER_VERSION
# error This file was generated by an older version of protoc-c which is incompatible with your libprotobuf-c headers. Please regenerate this file with a newer version of protoc-c.
#endif

#include "types.pb-c.h"
#include "sidechain_types.pb-c.h"

typedef struct _Tari__Rpc__TransactionKernel Tari__Rpc__TransactionKernel;
typedef struct _Tari__Rpc__TransactionInput Tari__Rpc__TransactionInput;
typedef struct _Tari__Rpc__TransactionOutput Tari__Rpc__TransactionOutput;
typedef struct _Tari__Rpc__OutputFeatures Tari__Rpc__OutputFeatures;
typedef struct _Tari__Rpc__AggregateBody Tari__Rpc__AggregateBody;
typedef struct _Tari__Rpc__Transaction Tari__Rpc__Transaction;
typedef struct _Tari__Rpc__UnblindedOutput Tari__Rpc__UnblindedOutput;


/* --- enums --- */


/* --- messages --- */

/*
 * The transaction kernel tracks the excess for a given transaction. For an explanation of what the excess is, and
 * why it is necessary, refer to the
 * [Mimblewimble TLU post](https://tlu.tarilabs.com/protocols/mimblewimble-1/sources/PITCHME.link.html?highlight=mimblewimble#mimblewimble).
 * The kernel also tracks other transaction metadata, such as the lock height for the transaction (i.e. the earliest
 * this transaction can be mined) and the transaction fee, in cleartext.
 */
struct  _Tari__Rpc__TransactionKernel
{
  ProtobufCMessage base;
  /*
   * Options for a kernel's structure or use
   */
  uint32_t features;
  /*
   * / Fee originally included in the transaction this proof is for (in MicroMinotari)
   */
  uint64_t fee;
  /*
   * This kernel is not valid earlier than lock_height blocks
   * The max lock_height of all *inputs* to this transaction
   */
  uint64_t lock_height;
  /*
   * Remainder of the sum of all transaction commitments. If the transaction
   * is well formed, amounts components should sum to zero and the excess
   * is hence a valid public key.
   */
  ProtobufCBinaryData excess;
  /*
   * The signature proving the excess is a valid public key, which signs
   * the transaction fee.
   */
  Tari__Rpc__Signature *excess_sig;
  /*
   * The hash of the kernel, as it appears in the MMR
   */
  ProtobufCBinaryData hash;
  /*
   * Version
   */
  uint32_t version;
  /*
   * Optional burned commitment
   */
  ProtobufCBinaryData burn_commitment;
};
#define TARI__RPC__TRANSACTION_KERNEL__INIT \
 { PROTOBUF_C_MESSAGE_INIT (&tari__rpc__transaction_kernel__descriptor) \
    , 0, 0, 0, {0,NULL}, NULL, {0,NULL}, 0, {0,NULL} }


/*
 * A transaction input.
 * Primarily a reference to an output being spent by the transaction.
 */
struct  _Tari__Rpc__TransactionInput
{
  ProtobufCMessage base;
  /*
   * The features of the output being spent. We will check maturity for all outputs.
   */
  Tari__Rpc__OutputFeatures *features;
  /*
   * The commitment referencing the output being spent.
   */
  ProtobufCBinaryData commitment;
  /*
   * Hash of the input, as it appears in the MMR
   */
  ProtobufCBinaryData hash;
  /*
   * The serialised script
   */
  ProtobufCBinaryData script;
  /*
   * The script input data, if any
   */
  ProtobufCBinaryData input_data;
  /*
   * A signature with k_s, signing the script, input data, and mined height
   */
  Tari__Rpc__ComAndPubSignature *script_signature;
  /*
   * The offset public key, K_O
   */
  ProtobufCBinaryData sender_offset_public_key;
  /*
   * The hash of the output this input is spending
   */
  ProtobufCBinaryData output_hash;
  /*
   * Covenant
   */
  ProtobufCBinaryData covenant;
  /*
   * Version
   */
  uint32_t version;
  /*
   * The encrypted data
   */
  ProtobufCBinaryData encrypted_data;
  /*
   * The minimum value of the commitment that is proven by the range proof (in MicroMinotari)
   */
  uint64_t minimum_value_promise;
  /*
   * The metadata signature for output this input is spending
   */
  Tari__Rpc__ComAndPubSignature *metadata_signature;
  /*
   * The rangeproof hash for output this input is spending
   */
  ProtobufCBinaryData rangeproof_hash;
};
#define TARI__RPC__TRANSACTION_INPUT__INIT \
 { PROTOBUF_C_MESSAGE_INIT (&tari__rpc__transaction_input__descriptor) \
    , NULL, {0,NULL}, {0,NULL}, {0,NULL}, {0,NULL}, NULL, {0,NULL}, {0,NULL}, {0,NULL}, 0, {0,NULL}, 0, NULL, {0,NULL} }


/*
 * Output for a transaction, defining the new ownership of coins that are being transferred. The commitment is a
 * blinded value for the output while the range proof guarantees the commitment includes a positive value without
 * overflow and the ownership of the private key.
 */
struct  _Tari__Rpc__TransactionOutput
{
  ProtobufCMessage base;
  /*
   * Options for an output's structure or use
   */
  Tari__Rpc__OutputFeatures *features;
  /*
   * The homomorphic commitment representing the output amount
   */
  ProtobufCBinaryData commitment;
  /*
   * A proof that the commitment is in the right range
   */
  Tari__Rpc__RangeProof *range_proof;
  /*
   * The hash of the output, as it appears in the MMR
   */
  ProtobufCBinaryData hash;
  /*
   * Tari script serialised script
   */
  ProtobufCBinaryData script;
  /*
   * Tari script offset public key, K_O
   */
  ProtobufCBinaryData sender_offset_public_key;
  /*
   * Metadata signature with the homomorphic commitment private values (amount and blinding factor) and the sender
   * offset private key
   */
  Tari__Rpc__ComAndPubSignature *metadata_signature;
  /*
   * Covenant
   */
  ProtobufCBinaryData covenant;
  /*
   * Version
   */
  uint32_t version;
  /*
   * Encrypted Pedersen commitment openings (value and mask) for the output
   */
  ProtobufCBinaryData encrypted_data;
  /*
   * The minimum value of the commitment that is proven by the range proof (in MicroMinotari)
   */
  uint64_t minimum_value_promise;
};
#define TARI__RPC__TRANSACTION_OUTPUT__INIT \
 { PROTOBUF_C_MESSAGE_INIT (&tari__rpc__transaction_output__descriptor) \
    , NULL, {0,NULL}, NULL, {0,NULL}, {0,NULL}, {0,NULL}, NULL, {0,NULL}, 0, {0,NULL}, 0 }


/*
 * Options for UTXOs
 */
struct  _Tari__Rpc__OutputFeatures
{
  ProtobufCMessage base;
  /*
   * Version
   */
  uint32_t version;
  /*
   * The type of output, eg Coinbase, all of which have different consensus rules
   */
  uint32_t output_type;
  /*
   * The maturity of the specific UTXO. This is the min lock height at which an UTXO can be spend. Coinbase UTXO
   * require a min maturity of the Coinbase_lock_height, this should be checked on receiving new blocks.
   */
  uint64_t maturity;
  /*
   * Additional arbitrary info in coinbase transactions supplied by miners
   */
  ProtobufCBinaryData coinbase_extra;
  /*
   * Features that are specific to a side chain
   */
  Tari__Rpc__SideChainFeature *sidechain_feature;
  /*
   * The type of range proof used in the output
   */
  uint32_t range_proof_type;
};
#define TARI__RPC__OUTPUT_FEATURES__INIT \
 { PROTOBUF_C_MESSAGE_INIT (&tari__rpc__output_features__descriptor) \
    , 0, 0, 0, {0,NULL}, NULL, 0 }


/*
 * The components of the block or transaction. The same struct can be used for either, since in Mimblewimble,
 * cut-through means that blocks and transactions have the same structure. The inputs, outputs and kernels should
 * be sorted by their Blake2b-256bit digest hash
 */
struct  _Tari__Rpc__AggregateBody
{
  ProtobufCMessage base;
  /*
   * List of inputs spent by the transaction.
   */
  size_t n_inputs;
  Tari__Rpc__TransactionInput **inputs;
  /*
   * List of outputs the transaction produces.
   */
  size_t n_outputs;
  Tari__Rpc__TransactionOutput **outputs;
  /*
   * Kernels contain the excesses and their signatures for transaction
   */
  size_t n_kernels;
  Tari__Rpc__TransactionKernel **kernels;
};
#define TARI__RPC__AGGREGATE_BODY__INIT \
 { PROTOBUF_C_MESSAGE_INIT (&tari__rpc__aggregate_body__descriptor) \
    , 0,NULL, 0,NULL, 0,NULL }


/*
 * A transaction which consists of a kernel offset and an aggregate body made up of inputs, outputs and kernels.
 */
struct  _Tari__Rpc__Transaction
{
  ProtobufCMessage base;
  ProtobufCBinaryData offset;
  Tari__Rpc__AggregateBody *body;
  ProtobufCBinaryData script_offset;
};
#define TARI__RPC__TRANSACTION__INIT \
 { PROTOBUF_C_MESSAGE_INIT (&tari__rpc__transaction__descriptor) \
    , {0,NULL}, NULL, {0,NULL} }


struct  _Tari__Rpc__UnblindedOutput
{
  ProtobufCMessage base;
  /*
   * Value of the output
   */
  uint64_t value;
  /*
   * Spending key of the output
   */
  ProtobufCBinaryData spending_key;
  /*
   * Options for an output's structure or use
   */
  Tari__Rpc__OutputFeatures *features;
  /*
   * Tari script serialised script
   */
  ProtobufCBinaryData script;
  /*
   * Tari script input data for spending
   */
  ProtobufCBinaryData input_data;
  /*
   * Tari script private key
   */
  ProtobufCBinaryData script_private_key;
  /*
   * Tari script offset pubkey, K_O
   */
  ProtobufCBinaryData sender_offset_public_key;
  /*
   * UTXO signature with the script offset private key, k_O
   */
  Tari__Rpc__ComAndPubSignature *metadata_signature;
  /*
   * The minimum height the script allows this output to be spent
   */
  uint64_t script_lock_height;
  /*
   * Covenant
   */
  ProtobufCBinaryData covenant;
  /*
   * Encrypted data
   */
  ProtobufCBinaryData encrypted_data;
  /*
   * The minimum value of the commitment that is proven by the range proof (in MicroMinotari)
   */
  uint64_t minimum_value_promise;
};
#define TARI__RPC__UNBLINDED_OUTPUT__INIT \
 { PROTOBUF_C_MESSAGE_INIT (&tari__rpc__unblinded_output__descriptor) \
    , 0, {0,NULL}, NULL, {0,NULL}, {0,NULL}, {0,NULL}, {0,NULL}, NULL, 0, {0,NULL}, {0,NULL}, 0 }


/* Tari__Rpc__TransactionKernel methods */
void   tari__rpc__transaction_kernel__init
                     (Tari__Rpc__TransactionKernel         *message);
size_t tari__rpc__transaction_kernel__get_packed_size
                     (const Tari__Rpc__TransactionKernel   *message);
size_t tari__rpc__transaction_kernel__pack
                     (const Tari__Rpc__TransactionKernel   *message,
                      uint8_t             *out);
size_t tari__rpc__transaction_kernel__pack_to_buffer
                     (const Tari__Rpc__TransactionKernel   *message,
                      ProtobufCBuffer     *buffer);
Tari__Rpc__TransactionKernel *
       tari__rpc__transaction_kernel__unpack
                     (ProtobufCAllocator  *allocator,
                      size_t               len,
                      const uint8_t       *data);
void   tari__rpc__transaction_kernel__free_unpacked
                     (Tari__Rpc__TransactionKernel *message,
                      ProtobufCAllocator *allocator);
/* Tari__Rpc__TransactionInput methods */
void   tari__rpc__transaction_input__init
                     (Tari__Rpc__TransactionInput         *message);
size_t tari__rpc__transaction_input__get_packed_size
                     (const Tari__Rpc__TransactionInput   *message);
size_t tari__rpc__transaction_input__pack
                     (const Tari__Rpc__TransactionInput   *message,
                      uint8_t             *out);
size_t tari__rpc__transaction_input__pack_to_buffer
                     (const Tari__Rpc__TransactionInput   *message,
                      ProtobufCBuffer     *buffer);
Tari__Rpc__TransactionInput *
       tari__rpc__transaction_input__unpack
                     (ProtobufCAllocator  *allocator,
                      size_t               len,
                      const uint8_t       *data);
void   tari__rpc__transaction_input__free_unpacked
                     (Tari__Rpc__TransactionInput *message,
                      ProtobufCAllocator *allocator);
/* Tari__Rpc__TransactionOutput methods */
void   tari__rpc__transaction_output__init
                     (Tari__Rpc__TransactionOutput         *message);
size_t tari__rpc__transaction_output__get_packed_size
                     (const Tari__Rpc__TransactionOutput   *message);
size_t tari__rpc__transaction_output__pack
                     (const Tari__Rpc__TransactionOutput   *message,
                      uint8_t             *out);
size_t tari__rpc__transaction_output__pack_to_buffer
                     (const Tari__Rpc__TransactionOutput   *message,
                      ProtobufCBuffer     *buffer);
Tari__Rpc__TransactionOutput *
       tari__rpc__transaction_output__unpack
                     (ProtobufCAllocator  *allocator,
                      size_t               len,
                      const uint8_t       *data);
void   tari__rpc__transaction_output__free_unpacked
                     (Tari__Rpc__TransactionOutput *message,
                      ProtobufCAllocator *allocator);
/* Tari__Rpc__OutputFeatures methods */
void   tari__rpc__output_features__init
                     (Tari__Rpc__OutputFeatures         *message);
size_t tari__rpc__output_features__get_packed_size
                     (const Tari__Rpc__OutputFeatures   *message);
size_t tari__rpc__output_features__pack
                     (const Tari__Rpc__OutputFeatures   *message,
                      uint8_t             *out);
size_t tari__rpc__output_features__pack_to_buffer
                     (const Tari__Rpc__OutputFeatures   *message,
                      ProtobufCBuffer     *buffer);
Tari__Rpc__OutputFeatures *
       tari__rpc__output_features__unpack
                     (ProtobufCAllocator  *allocator,
                      size_t               len,
                      const uint8_t       *data);
void   tari__rpc__output_features__free_unpacked
                     (Tari__Rpc__OutputFeatures *message,
                      ProtobufCAllocator *allocator);
/* Tari__Rpc__AggregateBody methods */
void   tari__rpc__aggregate_body__init
                     (Tari__Rpc__AggregateBody         *message);
size_t tari__rpc__aggregate_body__get_packed_size
                     (const Tari__Rpc__AggregateBody   *message);
size_t tari__rpc__aggregate_body__pack
                     (const Tari__Rpc__AggregateBody   *message,
                      uint8_t             *out);
size_t tari__rpc__aggregate_body__pack_to_buffer
                     (const Tari__Rpc__AggregateBody   *message,
                      ProtobufCBuffer     *buffer);
Tari__Rpc__AggregateBody *
       tari__rpc__aggregate_body__unpack
                     (ProtobufCAllocator  *allocator,
                      size_t               len,
                      const uint8_t       *data);
void   tari__rpc__aggregate_body__free_unpacked
                     (Tari__Rpc__AggregateBody *message,
                      ProtobufCAllocator *allocator);
/* Tari__Rpc__Transaction methods */
void   tari__rpc__transaction__init
                     (Tari__Rpc__Transaction         *message);
size_t tari__rpc__transaction__get_packed_size
                     (const Tari__Rpc__Transaction   *message);
size_t tari__rpc__transaction__pack
                     (const Tari__Rpc__Transaction   *message,
                      uint8_t             *out);
size_t tari__rpc__transaction__pack_to_buffer
                     (const Tari__Rpc__Transaction   *message,
                      ProtobufCBuffer     *buffer);
Tari__Rpc__Transaction *
       tari__rpc__transaction__unpack
                     (ProtobufCAllocator  *allocator,
                      size_t               len,
                      const uint8_t       *data);
void   tari__rpc__transaction__free_unpacked
                     (Tari__Rpc__Transaction *message,
                      ProtobufCAllocator *allocator);
/* Tari__Rpc__UnblindedOutput methods */
void   tari__rpc__unblinded_output__init
                     (Tari__Rpc__UnblindedOutput         *message);
size_t tari__rpc__unblinded_output__get_packed_size
                     (const Tari__Rpc__UnblindedOutput   *message);
size_t tari__rpc__unblinded_output__pack
                     (const Tari__Rpc__UnblindedOutput   *message,
                      uint8_t             *out);
size_t tari__rpc__unblinded_output__pack_to_buffer
                     (const Tari__Rpc__UnblindedOutput   *message,
                      ProtobufCBuffer     *buffer);
Tari__Rpc__UnblindedOutput *
       tari__rpc__unblinded_output__unpack
                     (ProtobufCAllocator  *allocator,
                      size_t               len,
                      const uint8_t       *data);
void   tari__rpc__unblinded_output__free_unpacked
                     (Tari__Rpc__UnblindedOutput *message,
                      ProtobufCAllocator *allocator);
/* --- per-message closures --- */

typedef void (*Tari__Rpc__TransactionKernel_Closure)
                 (const Tari__Rpc__TransactionKernel *message,
                  void *closure_data);
typedef void (*Tari__Rpc__TransactionInput_Closure)
                 (const Tari__Rpc__TransactionInput *message,
                  void *closure_data);
typedef void (*Tari__Rpc__TransactionOutput_Closure)
                 (const Tari__Rpc__TransactionOutput *message,
                  void *closure_data);
typedef void (*Tari__Rpc__OutputFeatures_Closure)
                 (const Tari__Rpc__OutputFeatures *message,
                  void *closure_data);
typedef void (*Tari__Rpc__AggregateBody_Closure)
                 (const Tari__Rpc__AggregateBody *message,
                  void *closure_data);
typedef void (*Tari__Rpc__Transaction_Closure)
                 (const Tari__Rpc__Transaction *message,
                  void *closure_data);
typedef void (*Tari__Rpc__UnblindedOutput_Closure)
                 (const Tari__Rpc__UnblindedOutput *message,
                  void *closure_data);

/* --- services --- */


/* --- descriptors --- */

extern const ProtobufCMessageDescriptor tari__rpc__transaction_kernel__descriptor;
extern const ProtobufCMessageDescriptor tari__rpc__transaction_input__descriptor;
extern const ProtobufCMessageDescriptor tari__rpc__transaction_output__descriptor;
extern const ProtobufCMessageDescriptor tari__rpc__output_features__descriptor;
extern const ProtobufCMessageDescriptor tari__rpc__aggregate_body__descriptor;
extern const ProtobufCMessageDescriptor tari__rpc__transaction__descriptor;
extern const ProtobufCMessageDescriptor tari__rpc__unblinded_output__descriptor;

PROTOBUF_C__END_DECLS


#endif  /* PROTOBUF_C_transaction_2eproto__INCLUDED */
